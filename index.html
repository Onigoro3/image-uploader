<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>画像アップローダー (解析・移動機能付き)</title>
    <style>
        /* (基本スタイルはほぼ変更なし) */
        body { font-family: sans-serif; line-height: 1.6; padding: 1em 2em; }
        hr { margin: 2em 0; }
        input[type="text"], input[type="search"], select { padding: 5px; border: 1px solid #ccc; border-radius: 4px; width: 95%; margin-bottom: 5px; font-size: 14px; } /* Font size */
        button { padding: 5px 10px; cursor: pointer; border-radius: 4px; font-size: 14px; }
        #upload-section { background: #f9f9f9; padding: 15px; border-radius: 8px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px 20px; }
        #upload-section label { font-weight: bold; display: block; margin-bottom: 3px; }
        #uploadStatus { font-weight: bold; grid-column: span 3; }
        #csvDownloader { display: inline-block; padding: 8px 12px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        #gallery-section { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .gallery-column { border: 1px solid #eee; padding: 10px; border-radius: 8px; background: #fafafa; min-height: 200px; max-height: 400px; overflow-y: auto; } /* Max height and scroll */
        .gallery-item { padding: 8px; border: 1px solid #ccc; border-radius: 5px; background-color: #f4f4f4; font-weight: bold; margin-bottom: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .gallery-item.active { background-color: #007bff; color: white; border-color: #007bff; }
        .gallery-item span { flex-grow: 1; margin-right: 5px; font-size: 14px; }
        .action-buttons { display: flex; gap: 3px; flex-shrink: 0; }
        .analyze-btn, .edit-btn, .delete-btn { border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-weight: bold; line-height: 20px; text-align: center; color: white; font-size: 12px; }
        /* ▼▼▼ 解析ボタンのスタイル ▼▼▼ */
        .analyze-btn { background: #17a2b8; /* Teal */ }
        .analyze-btn:hover { background: #138496; }
        /* ▲▲▲ 解析ボタンここまで ▲▲▲ */
        .edit-btn { background: #ffc107; } .edit-btn:hover { background: #e0a800; }
        .delete-btn { background: #dc3545; } .delete-btn:hover { background: #c82333; }
        #search-section { margin-top: 20px; border-top: 2px solid #eee; padding-top: 20px; }
        #searchInput { width: 300px; padding: 8px; }
        #image-gallery-container { grid-column: span 4; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 10px; padding-top: 10px; border-top: 2px solid #eee; }
        /* ▼▼▼ 画像アイテム (移動UI含む) のスタイル ▼▼▼ */
        .image-item { border: 1px solid #ddd; border-radius: 4px; padding: 5px; background: #fff; }
        .gallery-image { width: 100%; height: 130px; object-fit: cover; display: block; margin-bottom: 5px;}
        .move-controls { font-size: 12px; text-align: center;}
        .move-controls select { width: 80%; font-size: 11px; padding: 2px; margin-bottom: 3px; }
        .move-controls button { font-size: 11px; padding: 2px 5px; background-color: #6c757d; color: white; border:none; }
        .move-controls button:hover { background-color: #5a6268;}
        /* ▲▲▲ 画像アイテムここまで ▲▲▲ */
        .new-input { display: none; margin-top: 5px; }
        #analyzeStatus { margin-top: 10px; font-weight: bold; color: #17a2b8; } /* 解析ステータス用 */
    </style>
</head>
<body>

    {/* (HTML構造はほぼ変更なし、解析ステータス表示を追加) */}
    <div id="upload-section">
        {/* ... (アップロード欄 - 変更なし) ... */}
    </div><hr>
    <h3>履歴のダウンロード</h3>
    <a href="#" id="csvDownloader" style="visibility: hidden;">CSVダウンロード</a> <span id="csv-status-text">(フォルダ選択で有効化)</span>
    <span id="analyzeStatus"></span> {/* ★ 解析ステータス表示 */}
    <hr>
    <h3>階層別 ギャラリー</h3><p>大→中→小→フォルダ選択。(フォルダに A:解析 E:編集 X:削除)</p>
    <div id="gallery-section">
        <div id="cat1-container" class="gallery-column"><h4>大カテゴリ</h4><p class="loading-status">読込中...</p></div>
        {/* ... (中・小・フォルダカラム - 変更なし) ... */}
    </div>
    <div id="search-section" style="display: none;"><label for="searchInput">画像検索:</label><input type="search" id="searchInput" placeholder="..."></div>
    <div id="image-gallery-container"></div>

    <script>
        // --- HTML要素を取得 (変更なし) ---
        /* ... (変更なし) ... */
        const analyzeStatus = document.getElementById('analyzeStatus'); // ★ 解析ステータス

        // --- アップロード機能 (変更なし) ---
        uploadButton.addEventListener('click', async () => { /* ... (変更なし) ... */ });

        // --- ギャラリー機能 ---
        document.addEventListener('DOMContentLoaded', () => { loadCat1(); setupSelectListeners(); });
        function populateSelect(selectElement, items, currentSelection) { /* ... (変更なし) ... */ }
        function setupSelectListeners() { /* ... (変更なし) ... */ }
        function handleSelectChange(selectElement, newInputElement, level) { /* ... (変更なし) ... */ }
        function resetUploadUI(startLevel, createOnly = false){ /* ... (変更なし) ... */ }
        function resetAndAddCreateOption(selectElement) { /* ... (変更なし) ... */ }
        async function loadCat1() { /* ... (変更なし) ... */ }
        async function loadCat1Options(){ /* ... (変更なし) ... */ }
        async function loadCat2(cat1) { /* ... (変更なし) ... */ }
        async function loadCat2Options(cat1){ /* ... (変更なし) ... */ }
        async function loadCat3(cat1, cat2) { /* ... (変更なし) ... */ }
        async function loadCat3Options(cat1, cat2){ /* ... (変更なし) ... */ }
        async function loadFolders(cat1, cat2, cat3) { /* ... (変更なし) ... */ }

        // ▼▼▼ 汎用リスト読み込み関数 (★フォルダに「解析ボタン」を追加) ▼▼▼
        async function loadList(apiUrl, container, title, onClickCallback, addActionButtons = false, level = 0) {
            container.innerHTML = `<h4>${title}</h4><p class="loading-status">読込中...</p>`;
            try {
                const response = await fetch(apiUrl); if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const items = await response.json(); container.innerHTML = `<h4>${title}</h4>`;
                if (items.length === 0) { container.innerHTML += '<p>データなし</p>'; return; }
                items.forEach(itemName => {
                    const itemDiv = document.createElement('div'); itemDiv.className = 'gallery-item';
                    const nameSpan = document.createElement('span'); nameSpan.innerText = itemName;
                    nameSpan.addEventListener('click', () => { document.querySelectorAll(`#${container.id} .gallery-item`).forEach(el => el.classList.remove('active')); itemDiv.classList.add('active'); onClickCallback(itemName); });
                    itemDiv.appendChild(nameSpan);
                    if (addActionButtons) { // カテゴリとフォルダにボタン追加
                        const actionButtons = document.createElement('div'); actionButtons.className = 'action-buttons';
                        // ★ level 4 (フォルダ) の場合のみ解析ボタンを追加
                        if (level === 4) {
                            const analyzeBtn = document.createElement('button'); analyzeBtn.className = 'analyze-btn'; analyzeBtn.innerText = 'A'; analyzeBtn.title = 'フォルダ内画像を解析してCSV出力';
                            analyzeBtn.addEventListener('click', (e) => { e.stopPropagation(); analyzeFolder(itemName); }); // ★解析関数呼び出し
                            actionButtons.appendChild(analyzeBtn);
                        }
                        const editBtn = document.createElement('button'); editBtn.className = 'edit-btn'; editBtn.innerText = 'E'; editBtn.title = '名前変更';
                        editBtn.addEventListener('click', (e) => { e.stopPropagation(); renameItem(itemName, level); });
                        const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-btn'; deleteBtn.innerText = 'X'; deleteBtn.title = '削除';
                        deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteItem(itemName, level); });
                        actionButtons.appendChild(editBtn); actionButtons.appendChild(deleteBtn);
                        itemDiv.appendChild(actionButtons);
                    }
                    container.appendChild(itemDiv);
                });
            } catch (error) { console.error(`${title}読み込みエラー:`, error); container.innerHTML = `<h4>${title}</h4><p style="color: red;">失敗</p>`; }
        }
        // ▲▲▲ 汎用リスト読み込み関数 ここまで ▲▲▲

        // UIリセット関数 (変更なし)
        function resetUI(startLevel) { /* ... (変更なし) ... */ }
        // 画像読み込みトリガー (変更なし)
        async function loadImages(folderName) { /* ... (変更なし) ... */ }
        // 検索イベントリスナー (変更なし)
        let searchTimeout; searchInput.addEventListener('input', () => { /* ... (変更なし) ... */ });

        // ▼▼▼ 画像取得・表示関数 (★移動UIを追加) ▼▼▼
        async function displayImages(folderName, searchTerm) {
            try {
                galleryContainer.innerHTML = '<p>読込中...</p>';
                const encodedFolderName = encodeURIComponent(folderName);
                let apiUrl = searchTerm ? `/api/search?folder=${encodedFolderName}&q=${encodeURIComponent(searchTerm)}` : `/api/images/${encodedFolderName}`;
                const response = await fetch(apiUrl); if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const images = await response.json(); galleryContainer.innerHTML = ''; // クリア

                if (images.length === 0) { galleryContainer.innerHTML = searchTerm ? '<p>検索結果なし</p>' : '<p>画像なし</p>'; }
                else {
                    // ★ 全カテゴリ・フォルダリストを事前に取得（移動先ドロップダウン用）
                    const allCat1 = await fetch('/api/cat1').then(res => res.ok ? res.json() : []);
                    let allFoldersGrouped = {}; // { cat1: { cat2: { cat3: [folder1, folder2] } } } の形式で格納

                    images.forEach(imgData => {
                        // 1. 画像アイテム全体のコンテナ
                        const itemContainer = document.createElement('div');
                        itemContainer.className = 'image-item';

                        // 2. 画像本体
                        const img = document.createElement('img');
                        img.className='gallery-image'; img.src=imgData.url; img.alt=imgData.title; img.title=imgData.title;
                        itemContainer.appendChild(img);

                        // 3. ★ 移動用コントロール
                        const moveControls = document.createElement('div');
                        moveControls.className = 'move-controls';

                        // 移動先カテゴリ選択 (3つのSelect)
                        const selCat1 = document.createElement('select'); selCat1.title = "移動先 大カテゴリ"; populateSelectSimple(selCat1, allCat1);
                        const selCat2 = document.createElement('select'); selCat2.title = "移動先 中カテゴリ";
                        const selCat3 = document.createElement('select'); selCat3.title = "移動先 小カテゴリ";
                        const selFolder = document.createElement('select'); selFolder.title = "移動先 フォルダ"; // フォルダもSelectに

                        // カテゴリ選択の連動処理 (移動用)
                        selCat1.onchange = async () => {
                             selCat2.innerHTML = '<option value="">---</option>'; selCat3.innerHTML = '<option value="">---</option>'; selFolder.innerHTML = '<option value="">---</option>';
                             if(selCat1.value) { const cat2s = await fetch(`/api/cat2/${encodeURIComponent(selCat1.value)}`).then(r => r.ok ? r.json():[]); populateSelectSimple(selCat2, cat2s); }
                        };
                         selCat2.onchange = async () => {
                             selCat3.innerHTML = '<option value="">---</option>'; selFolder.innerHTML = '<option value="">---</option>';
                             if(selCat1.value && selCat2.value) { const cat3s = await fetch(`/api/cat3/${encodeURIComponent(selCat1.value)}/${encodeURIComponent(selCat2.value)}`).then(r => r.ok ? r.json():[]); populateSelectSimple(selCat3, cat3s); }
                        };
                         selCat3.onchange = async () => {
                             selFolder.innerHTML = '<option value="">---</option>';
                             if(selCat1.value && selCat2.value && selCat3.value) { const folders = await fetch(`/api/folders/${encodeURIComponent(selCat1.value)}/${encodeURIComponent(selCat2.value)}/${encodeURIComponent(selCat3.value)}`).then(r => r.ok ? r.json():[]); populateSelectSimple(selFolder, folders); }
                        };

                        // 移動ボタン
                        const moveBtn = document.createElement('button');
                        moveBtn.innerText = '移動';
                        moveBtn.onclick = () => {
                            if (selCat1.value && selCat2.value && selCat3.value && selFolder.value) {
                                moveImage(imgData.title, selCat1.value, selCat2.value, selCat3.value, selFolder.value);
                            } else { alert('移動先のカテゴリとフォルダをすべて選択してください。'); }
                        };

                        moveControls.appendChild(selCat1); moveControls.appendChild(selCat2); moveControls.appendChild(selCat3); moveControls.appendChild(selFolder);
                        moveControls.appendChild(moveBtn);
                        itemContainer.appendChild(moveControls);

                        galleryContainer.appendChild(itemContainer); // 全体をギャラリーに追加
                    });
                }
                // CSVボタン表示
                csvButton.href = `/download-csv?folder=${encodedFolderName}`; csvButton.style.visibility = 'visible'; csvStatus.innerText = `「${folderName}」CSV`;
            } catch (error) { console.error('画像読込/検索エラー:', error); galleryContainer.innerHTML = '<p style="color: red;">失敗</p>'; csvButton.style.visibility = 'hidden'; csvStatus.innerText = '(フォルダ選択で有効化)'; }
        }
        // ▲▲▲ 画像取得・表示関数 ここまで ▲▲▲

        // ★ 移動用ドロップダウン生成ヘルパー (新規作成なし版)
        function populateSelectSimple(selectElement, items) {
            selectElement.innerHTML = '<option value="">---</option>'; // デフォルト
            items.forEach(item => { const option = document.createElement('option'); option.value = item; option.text = item; selectElement.appendChild(option); });
        }

        // (H) 削除関数 (変更なし)
        async function deleteItem(itemName, level) { /* ... (変更なし) ... */ }
        // (I) 名前変更関数 (変更なし)
        async function renameItem(oldItemName, level) { /* ... (変更なし) ... */ }

        // ▼▼▼ (J) 【新機能】 フォルダ解析関数 ▼▼▼
        async function analyzeFolder(folderName) {
            analyzeStatus.innerText = `「${folderName}」を解析中...時間がかかる場合があります。`;
            analyzeStatus.style.color = '#17a2b8';
            try {
                const encodedFolderName = encodeURIComponent(folderName);
                // ★ サーバーの解析APIを叩く (POSTメソッド)
                const response = await fetch(`/api/analyze/${encodedFolderName}`, { method: 'POST' });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: `HTTP ${response.status}` }));
                    throw new Error(errorData.message || `HTTP ${response.status}`);
                }

                // ★ レスポンス (CSVファイル) をダウンロードさせる
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                // ファイル名をレスポンスヘッダーから取得 (サーバー側で設定が必要)
                const disposition = response.headers.get('Content-Disposition');
                let filename = `analysis_${folderName}.csv`; // デフォルトファイル名
                if (disposition && disposition.indexOf('attachment') !== -1) {
                    const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                    const matches = filenameRegex.exec(disposition);
                    if (matches != null && matches[1]) {
                      filename = matches[1].replace(/['"]/g, '');
                      // URLエンコードされている可能性があるのでデコード
                      filename = decodeURIComponent(filename);
                    }
                }
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();

                analyzeStatus.innerText = `「${folderName}」の解析結果CSVをダウンロードしました。`;
                analyzeStatus.style.color = 'green';

            } catch (error) {
                console.error('フォルダ解析エラー:', error);
                analyzeStatus.innerText = `解析失敗: ${error.message}`;
                analyzeStatus.style.color = 'red';
            }
        }
        // ▲▲▲ (J) フォルダ解析関数 ここまで ▲▲▲

        // ▼▼▼ (K) 【新機能】 画像移動関数 ▼▼▼
        async function moveImage(imageTitle, newCat1, newCat2, newCat3, newFolder) {
            try {
                statusP.style.color = 'blue';
                statusP.innerText = `「${imageTitle}」を移動中...`;

                const encodedImageTitle = encodeURIComponent(imageTitle);
                const response = await fetch(`/api/image/${encodedImageTitle}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ category1: newCat1, category2: newCat2, category3: newCat3, folderName: newFolder })
                });

                 if (!response.ok) {
                    const errData = await response.json().catch(() => ({ message: `HTTP ${response.status}` }));
                    throw new Error(errData.message || `HTTP ${response.status}`);
                }
                const data = await response.json();
                statusP.innerText = data.message; statusP.style.color = 'green';

                // ★ 現在表示中のフォルダの画像を再読み込みして、移動した画像が消えるようにする
                if(selections.folder) {
                    await displayImages(selections.folder, searchInput.value.trim());
                }

            } catch (error) {
                console.error('画像移動エラー:', error);
                statusP.innerText = `移動失敗: ${error.message}`; statusP.style.color = 'red';
            }
        }
        // ▲▲▲ (K) 画像移動関数 ここまで ▲▲▲

    </script>
</body>
</html>